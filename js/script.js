// Placeholder for JavaScript logic
// This script will handle:
// 1. Fetching data (initially from a JSON file generated by a script)
// 2. Populating categories and items in the sidebar
// 3. Handling search functionality
// 4. Displaying comparison images when an item is selected
// 5. Toggling category visibility

// Import Three.js and FBX loader
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';

document.addEventListener('DOMContentLoaded', () => {
    const categoriesContainer = document.getElementById('categories');
    const comparisonArea = document.getElementById('comparison-area');
    const searchInput = document.getElementById('search-input');
    const noItemSelectedMessage = document.getElementById('no-item-selected');
    const themeToggle = document.getElementById('theme-toggle');
    const lightIcon = document.getElementById('light-icon');
    const darkIcon = document.getElementById('dark-icon');
    const themeText = document.getElementById('theme-text');
    let allItems = []; // To store all items for searching
    let currentData = null; // Store the fetched data
    let modelViewer = null; // 3D model viewer instance

    // Create popup elements
    const popupOverlay = document.createElement('div');
    popupOverlay.className = 'popup-overlay';
    popupOverlay.innerHTML = `
        <div class="popup-content">
            <button class="popup-close">×</button>
            <div class="popup-container">
                <img class="popup-image" src="" alt="Enlarged image" style="display: none;">
                <div class="model-container" style="display: none;">
                    <canvas class="model-canvas"></canvas>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(popupOverlay);

    const popupImage = popupOverlay.querySelector('.popup-image');
    const modelContainer = popupOverlay.querySelector('.model-container');
    const modelCanvas = popupOverlay.querySelector('.model-canvas');
    const closeButton = popupOverlay.querySelector('.popup-close');

    // Function to show image popup
    function showImagePopup(imageSrc) {
        popupImage.src = imageSrc;
        popupImage.style.display = 'block';
        modelContainer.style.display = 'none';
        popupOverlay.classList.add('active');
        document.body.style.overflow = 'hidden'; // Prevent scrolling when popup is open
    }

    // Function to show 3D model popup
    function show3DModelPopup(modelSrc) {
        popupImage.style.display = 'none';
        modelContainer.style.display = 'block';
        popupOverlay.classList.add('active');
        document.body.style.overflow = 'hidden';
        
        // Initialize 3D viewer if needed
        if (!modelViewer) {
            initModel3DViewer();
        }
        
        // Load the 3D model
        loadModel(modelSrc);
    }

    // Function to initialize 3D viewer
    function initModel3DViewer() {
        modelViewer = {
            scene: null,
            camera: null,
            renderer: null,
            controls: null,
            model: null,
            clock: null,
            mixer: null,
            animations: [],
            currentAnimation: 0,
            grid: null,
            lights: {
                ambient: null,
                directional: null,
                hemisphere: null,
                spot: null,
                point: null,
                enabled: true
            },
            dispose: function() {
                if (this.model) {
                    this.scene.remove(this.model);
                    // Dispose geometries and materials
                    if (this.model.traverse) {
                        this.model.traverse((child) => {
                            if (child.isMesh) {
                                child.geometry.dispose();
                                if (child.material.isMaterial) {
                                    disposeTextures(child.material);
                                    child.material.dispose();
                                } else if (Array.isArray(child.material)) {
                                    child.material.forEach(material => {
                                        disposeTextures(material);
                                        material.dispose();
                                    });
                                }
                            }
                        });
                    }
                    this.model = null;
                }
                if (this.mixer) {
                    this.mixer = null;
                }
                this.animations = [];
            },
            setDefaultView: function() {
                if (!this.model) return;
                
                // Get model bounding box
                const box = new THREE.Box3().setFromObject(this.model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                // Reset position
                this.model.position.set(-center.x, -center.y, -center.z);
                
                // Position camera to face the front of the model (Z-axis in Unity is forward)
                // In Three.js, we need to position camera at -Z to look toward +Z
                const maxDim = Math.max(size.x, size.y, size.z);
                const distance = maxDim * 2;
                
                // Position camera in front of the model (looking toward +Z axis)
                this.camera.position.set(0, size.y / 2, -distance);
                this.camera.lookAt(new THREE.Vector3(0, size.y / 3, 0));
                
                // Update controls target to model center
                this.controls.target.set(0, size.y / 3, 0);
                this.controls.update();
            },
            toggleLights: function() {
                this.lights.enabled = !this.lights.enabled;
                
                // Toggle ambient light
                if (this.lights.ambient) {
                    this.lights.ambient.intensity = this.lights.enabled ? 0.5 : 0;
                }
                
                // Toggle directional light
                if (this.lights.directional) {
                    this.lights.directional.intensity = this.lights.enabled ? 1.0 : 0;
                }
                
                // Toggle hemisphere light
                if (this.lights.hemisphere) {
                    this.lights.hemisphere.intensity = this.lights.enabled ? 1.0 : 0;
                }
                
                // Toggle spot light
                if (this.lights.spot) {
                    this.lights.spot.intensity = this.lights.enabled ? 1.0 : 0;
                }
                
                // Toggle point light
                if (this.lights.point) {
                    this.lights.point.intensity = this.lights.enabled ? 1.0 : 0;
                }
                
                // Update light button text
                const lightBtn = modelContainer.querySelector('.light-toggle');
                if (lightBtn) {
                    lightBtn.textContent = this.lights.enabled ? 'Tắt đèn' : 'Bật đèn';
                }
            },
            playAnimation: function(index) {
                if (!this.mixer || this.animations.length === 0) return;
                
                // Stop all current animations
                this.mixer.stopAllAction();
                
                // Validate index
                this.currentAnimation = Math.max(0, Math.min(index, this.animations.length - 1));
                
                // Play the selected animation
                const action = this.mixer.clipAction(this.animations[this.currentAnimation]);
                action.reset();
                action.setLoop(THREE.LoopRepeat);
                action.clampWhenFinished = false;
                action.play();
                
                // Update animation info
                this.updateAnimationInfo();
            },
            nextAnimation: function() {
                this.currentAnimation = (this.currentAnimation + 1) % this.animations.length;
                this.playAnimation(this.currentAnimation);
            },
            prevAnimation: function() {
                this.currentAnimation = (this.currentAnimation - 1 + this.animations.length) % this.animations.length;
                this.playAnimation(this.currentAnimation);
            },
            updateAnimationInfo: function() {
                const animInfo = modelContainer.querySelector('.animation-info');
                if (animInfo && this.animations.length > 0) {
                    const anim = this.animations[this.currentAnimation];
                    // Display animation name and make it more visible
                    const animName = anim.name || `Animation ${this.currentAnimation + 1}`;
                    animInfo.innerHTML = `<strong>Animation:</strong> ${animName}<br>(${this.currentAnimation + 1}/${this.animations.length})`;
                    animInfo.style.display = 'block';
                    
                    // Also log animation details for debugging
                    console.log('Current animation:', {
                        name: anim.name,
                        duration: anim.duration,
                        index: this.currentAnimation,
                        total: this.animations.length
                    });
                } else if (animInfo) {
                    animInfo.style.display = 'none';
                }
            }
        };

        // Set up the scene
        modelViewer.scene = new THREE.Scene();
        modelViewer.scene.background = new THREE.Color(0x222222);

        // Set up the camera
        modelViewer.camera = new THREE.PerspectiveCamera(45, modelContainer.clientWidth / modelContainer.clientHeight, 0.1, 1000);
        modelViewer.camera.position.set(5, 5, 5);
        
        // Set up the renderer
        modelViewer.renderer = new THREE.WebGLRenderer({ 
            canvas: modelCanvas,
            antialias: true
        });
        modelViewer.renderer.setSize(modelContainer.clientWidth, modelContainer.clientHeight);
        modelViewer.renderer.setPixelRatio(window.devicePixelRatio);
        modelViewer.renderer.shadowMap.enabled = true;
        modelViewer.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        // Set up the controls
        modelViewer.controls = new OrbitControls(modelViewer.camera, modelViewer.renderer.domElement);
        modelViewer.controls.enableDamping = true;
        modelViewer.controls.dampingFactor = 0.05;
        modelViewer.controls.maxDistance = 100;
        
        // Set up the grid helper
        const gridSize = 20;
        const gridDivisions = 20;
        modelViewer.grid = new THREE.GridHelper(gridSize, gridDivisions, 0x555555, 0x333333);
        // Rotate grid to match Unity's Z-forward coordinate system
        modelViewer.grid.rotation.x = Math.PI / 2; 
        modelViewer.grid.position.y = 0;
        modelViewer.scene.add(modelViewer.grid);
        
        // Set up lighting
        // Ambient light
        modelViewer.lights.ambient = new THREE.AmbientLight(0xffffff, 0.5);
        modelViewer.scene.add(modelViewer.lights.ambient);
        
        // Directional light (sun-like)
        modelViewer.lights.directional = new THREE.DirectionalLight(0xffffff, 1);
        // Position directional light for Unity coordinate system (in front and above)
        modelViewer.lights.directional.position.set(0, 5, -5);
        modelViewer.lights.directional.castShadow = true;
        modelViewer.lights.directional.shadow.mapSize.width = 1024;
        modelViewer.lights.directional.shadow.mapSize.height = 1024;
        modelViewer.scene.add(modelViewer.lights.directional);

        // Hemisphere light (sky and ground)
        modelViewer.lights.hemisphere = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
        modelViewer.scene.add(modelViewer.lights.hemisphere);
        
        // Point light (like a light bulb)
        modelViewer.lights.point = new THREE.PointLight(0xffffff, 1, 100);
        // Position point light for Unity coordinate system (to the side and above)
        modelViewer.lights.point.position.set(5, 10, 0);
        modelViewer.lights.point.castShadow = true;
        modelViewer.scene.add(modelViewer.lights.point);
        
        // Add a clock for animations
        modelViewer.clock = new THREE.Clock();
        
        // Create control UI for model viewer
        createModelViewerUI();
        
        // Animation
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            modelViewer.controls.update();
            
            // Update any animations
            if (modelViewer.mixer) {
                modelViewer.mixer.update(modelViewer.clock.getDelta());
            }
            
            // Render the scene
            modelViewer.renderer.render(modelViewer.scene, modelViewer.camera);
        }
        
        // Start the animation loop
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (modelViewer.camera && modelViewer.renderer) {
                modelViewer.camera.aspect = modelContainer.clientWidth / modelContainer.clientHeight;
                modelViewer.camera.updateProjectionMatrix();
                modelViewer.renderer.setSize(modelContainer.clientWidth, modelContainer.clientHeight);
            }
        });
    }

    // Create UI controls for model viewer
    function createModelViewerUI() {
        // Create UI container
        const uiContainer = document.createElement('div');
        uiContainer.className = 'model-controls';
        modelContainer.appendChild(uiContainer);
        
        // Reset camera button
        const resetBtn = document.createElement('button');
        resetBtn.className = 'model-control-btn reset-camera';
        resetBtn.textContent = 'Reset Camera';
        resetBtn.addEventListener('click', () => {
            if (modelViewer) modelViewer.setDefaultView();
        });
        uiContainer.appendChild(resetBtn);
        
        // Toggle lights button
        const lightBtn = document.createElement('button');
        lightBtn.className = 'model-control-btn light-toggle';
        lightBtn.textContent = 'Tắt đèn';
        lightBtn.addEventListener('click', () => {
            if (modelViewer) modelViewer.toggleLights();
        });
        uiContainer.appendChild(lightBtn);
        
        // Animation name display
        const animTitle = document.createElement('div');
        animTitle.className = 'animation-title';
        animTitle.textContent = 'Animation:';
        animTitle.style.display = 'block';
        uiContainer.appendChild(animTitle);
        
        // Animation controls
        const animContainer = document.createElement('div');
        animContainer.className = 'animation-controls';
        
        // Previous animation
        const prevBtn = document.createElement('button');
        prevBtn.className = 'model-control-btn prev-animation';
        prevBtn.textContent = '←';
        prevBtn.title = 'Previous Animation';
        prevBtn.addEventListener('click', () => {
            if (modelViewer) modelViewer.prevAnimation();
        });
        
        // Animation info
        const animInfo = document.createElement('span');
        animInfo.className = 'animation-info';
        animInfo.textContent = 'No animations';
        animInfo.style.display = 'none';
        
        // Next animation
        const nextBtn = document.createElement('button');
        nextBtn.className = 'model-control-btn next-animation';
        nextBtn.textContent = '→';
        nextBtn.title = 'Next Animation';
        nextBtn.addEventListener('click', () => {
            if (modelViewer) modelViewer.nextAnimation();
        });
        
        animContainer.appendChild(prevBtn);
        animContainer.appendChild(animInfo);
        animContainer.appendChild(nextBtn);
        uiContainer.appendChild(animContainer);
    }

    // Helper function to dispose textures
    function disposeTextures(material) {
        if (material.map) material.map.dispose();
        if (material.lightMap) material.lightMap.dispose();
        if (material.bumpMap) material.bumpMap.dispose();
        if (material.normalMap) material.normalMap.dispose();
        if (material.specularMap) material.specularMap.dispose();
        if (material.envMap) material.envMap.dispose();
        if (material.alphaMap) material.alphaMap.dispose();
        if (material.aoMap) material.aoMap.dispose();
        if (material.displacementMap) material.displacementMap.dispose();
        if (material.emissiveMap) material.emissiveMap.dispose();
        if (material.metalnessMap) material.metalnessMap.dispose();
        if (material.roughnessMap) material.roughnessMap.dispose();
    }

    // Function to load a 3D model
    function loadModel(modelSrc) {
        // Show loading message
        modelContainer.innerHTML = '<div class="loading-spinner">Đang tải mô hình 3D...</div>';
        
        // Clear previous model
        if (modelViewer.model) {
            modelViewer.dispose();
        }
        
        // Create a new canvas
        modelContainer.innerHTML = '';
        const newCanvas = document.createElement('canvas');
        newCanvas.className = 'model-canvas';
        modelContainer.appendChild(newCanvas);
        
        // Update renderer with new canvas
        modelViewer.renderer = new THREE.WebGLRenderer({ 
            canvas: newCanvas,
            antialias: true
        });
        modelViewer.renderer.setSize(modelContainer.clientWidth, modelContainer.clientHeight);
        modelViewer.renderer.setPixelRatio(window.devicePixelRatio);
        modelViewer.renderer.shadowMap.enabled = true;
        
        // Update controls with new domElement
        modelViewer.controls = new OrbitControls(modelViewer.camera, modelViewer.renderer.domElement);
        modelViewer.controls.enableDamping = true;
        modelViewer.controls.dampingFactor = 0.05;
        
        // Recreate the UI
        createModelViewerUI();
        
        // Load the model
        const loader = new FBXLoader();
        loader.load(
            modelSrc,
            (fbx) => {
                // Successfully loaded the model
                modelViewer.model = fbx;
                
                // Setup shadows for all meshes
                fbx.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                // Adjust model rotation to match Unity's coordinate system
                // Unity: X=right, Y=up, Z=forward
                // Three.js: X=right, Y=up, Z=out of screen
                // Rotate 180 degrees around Y-axis to flip Z direction
                fbx.rotation.y = Math.PI; // 180 degrees in radians
                
                // Add to scene
                modelViewer.scene.add(fbx);
                
                // Set default view
                modelViewer.setDefaultView();
                
                // Handle animations if present
                if (fbx.animations && fbx.animations.length > 0) {
                    console.log('Model has animations:', fbx.animations.length);
                    
                    // Debug: log all animation names
                    fbx.animations.forEach((anim, index) => {
                        console.log(`Animation ${index}:`, anim.name || 'Unnamed', 'Duration:', anim.duration);
                    });
                    
                    modelViewer.mixer = new THREE.AnimationMixer(fbx);
                    modelViewer.animations = fbx.animations;
                    
                    // Make animation controls visible
                    const animContainer = modelContainer.querySelector('.animation-controls');
                    if (animContainer) {
                        animContainer.style.display = 'flex';
                    }
                    
                    // Play the first animation by default
                    modelViewer.currentAnimation = 0;
                    modelViewer.playAnimation(0);
                } else {
                    console.log('No animations found in model');
                    // Hide animation controls if no animations
                    const animContainer = modelContainer.querySelector('.animation-controls');
                    if (animContainer) {
                        animContainer.style.display = 'none';
                    }
                }
            },
            (xhr) => {
                // Progress callback
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            (error) => {
                // Error callback
                console.error('Error loading model:', error);
                modelContainer.innerHTML = '<div class="error-message">Không thể tải mô hình 3D</div>';
            }
        );
    }

    // Function to hide popup
    function hideImagePopup() {
        popupOverlay.classList.remove('active');
        document.body.style.overflow = ''; // Restore scrolling
    }

    // Add event listeners for popup
    closeButton.addEventListener('click', hideImagePopup);
    popupOverlay.addEventListener('click', (e) => {
        if (e.target === popupOverlay) {
            hideImagePopup();
        }
    });

    // Add keyboard support for closing popup
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && popupOverlay.classList.contains('active')) {
            hideImagePopup();
        }
    });

    // Theme toggle functionality
    function initTheme() {
        // Check for saved theme preference or use system preference
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            enableDarkMode();
        } else if (savedTheme === 'light') {
            enableLightMode();
        } else {
            // Use system preference if no saved preference
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                enableDarkMode();
            }
        }
    }

    function enableDarkMode() {
        document.body.classList.add('dark-theme');
        lightIcon.style.display = 'none';
        darkIcon.style.display = 'block';
        themeText.textContent = 'Chế độ sáng';
        localStorage.setItem('theme', 'dark');
    }

    function enableLightMode() {
        document.body.classList.remove('dark-theme');
        lightIcon.style.display = 'block';
        darkIcon.style.display = 'none';
        themeText.textContent = 'Chế độ tối';
        localStorage.setItem('theme', 'light');
    }

    themeToggle.addEventListener('click', () => {
        if (document.body.classList.contains('dark-theme')) {
            enableLightMode();
        } else {
            enableDarkMode();
        }
    });

    // Initialize theme
    initTheme();

    // Function to fetch data and initialize the page
    async function fetchData() {
        try {
            // Use the GitHub raw URL directly as it's confirmed to be working
            const directUrl = 'https://raw.githubusercontent.com/kienbb/MU-Art-Compare/main/docs/data.json';
            
            console.log('Fetching data directly from GitHub:', directUrl);
            
            const response = await fetch(directUrl);
            if (!response.ok) {
                console.error(`Failed to fetch from GitHub raw. Status: ${response.status}`);
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            currentData = await response.json();
            populateTreeSidebar(currentData.categories);
            collectAllItems(currentData.categories);
        } catch (error) {
            console.error("Could not fetch data:", error);
            categoriesContainer.innerHTML = `<p style="color: red;">Lỗi tải dữ liệu. Vui lòng kiểm tra kết nối mạng và thử lại.</p>`;
        }
    }

    // Function to populate the sidebar as a tree
    function populateTreeSidebar(categoriesData) {
        categoriesContainer.innerHTML = ''; // Clear previous content
        const treeRoot = document.createElement('ul');
        treeRoot.classList.add('category-tree');

        // Clear and setup content area structure
        const content = document.getElementById('content');
        content.innerHTML = `
            <div class="content-header">
                <h2>So sánh chi tiết</h2>
            </div>
            <div class="content-body">
                <div id="comparison-area">
                    <p id="no-item-selected">Chọn một mục từ danh sách bên trái để xem so sánh.</p>
                </div>
            </div>
        `;

        if (!categoriesData || Object.keys(categoriesData).length === 0) {
            const noDataMsg = document.createElement('p');
            noDataMsg.textContent = 'Không có dữ liệu danh mục. Vui lòng thêm dữ liệu vào thư mục assets và chạy "npm run scan".';
            noDataMsg.style.color = 'red';
            categoriesContainer.appendChild(noDataMsg);
            return;
        }

        for (const categoryName in categoriesData) {
            const items = categoriesData[categoryName];
            if (items && items.length > 0) {
                // Create category node
                const categoryNode = document.createElement('li');
                categoryNode.classList.add('category-node');

                const categoryTitle = document.createElement('span');
                categoryTitle.textContent = categoryName;
                categoryTitle.classList.add('category-title');
                categoryNode.appendChild(categoryTitle);

                // Create list for items within the category
                const itemList = document.createElement('ul');
                itemList.classList.add('item-list'); // Initially hidden by CSS

                items.forEach(item => {
                    const itemNode = document.createElement('li');
                    itemNode.classList.add('item-node');
                    itemNode.textContent = `${item.id ? item.id + ' - ' : ''}${item.name}`; // Display ID and name
                    itemNode.dataset.category = categoryName;
                    itemNode.dataset.itemId = item.id || item.name.replace(/ /g, '_'); // Use ID or name as identifier
                    itemNode.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent category toggle when item is clicked
                        displayComparison(item);
                    });
                    itemList.appendChild(itemNode);
                });

                categoryNode.appendChild(itemList);

                // Add click listener to category title to toggle item list
                categoryTitle.addEventListener('click', () => {
                    categoryNode.classList.toggle('expanded');
                });

                treeRoot.appendChild(categoryNode);
            } else {
                // Create empty category node with message
                const categoryNode = document.createElement('li');
                categoryNode.classList.add('category-node');

                const categoryTitle = document.createElement('span');
                categoryTitle.textContent = categoryName;
                categoryTitle.classList.add('category-title');
                categoryNode.appendChild(categoryTitle);

                const emptyMsg = document.createElement('p');
                emptyMsg.textContent = 'Không có mục nào trong danh mục này';
                emptyMsg.style.fontSize = '0.9em';
                emptyMsg.style.fontStyle = 'italic';
                emptyMsg.style.marginLeft = '20px';

                categoryNode.appendChild(emptyMsg);
                treeRoot.appendChild(categoryNode);
            }
        }
        categoriesContainer.appendChild(treeRoot);
    }

    // Function to collect all items for search functionality
    function collectAllItems(categoriesData) {
        allItems = [];
        for (const categoryName in categoriesData) {
            categoriesData[categoryName].forEach(item => {
                allItems.push(item);
            });
        }
    }

    // Function to display comparison images
    function displayComparison(item) {
        const comparisonArea = document.getElementById('comparison-area');
        comparisonArea.innerHTML = ''; // Clear previous comparison

        // Update the title to include the selected item name
        const contentTitle = document.querySelector('.content-header h2');
        contentTitle.textContent = `So sánh chi tiết - ${item.id ? item.id + ' - ' : ''}${item.name}`;

        // Create containers for each version
        const awakenContainer = createImageContainer('MU Awaken', item.images.awaken, item.models?.awaken);
        const originContainer = createImageContainer('MU Origin', item.images.origin, item.models?.origin);

        comparisonArea.appendChild(awakenContainer);
        comparisonArea.appendChild(originContainer);

        // Highlight selected item in sidebar
        highlightSelectedItem(item);
    }

    // Helper function to create image container for a version
    function createImageContainer(versionName, images, models) {
        const container = document.createElement('div');
        container.classList.add('image-container');

        const title = document.createElement('h4');
        title.textContent = versionName;
        container.appendChild(title);

        // Add images section
        if (images && images.length > 0) {
            const imagesTitle = document.createElement('h5');
            imagesTitle.textContent = 'Hình ảnh';
            container.appendChild(imagesTitle);

            images.forEach(imgPath => {
                // Create a fixed-size container for the image
                const previewContainer = document.createElement('div');
                previewContainer.classList.add('image-preview-container');
                container.appendChild(previewContainer);
                
                // Create and add the image to the container
                const img = document.createElement('img');
                img.src = imgPath;
                img.alt = `${versionName} image`;
                
                // Add click event for popup
                previewContainer.addEventListener('click', () => {
                    showImagePopup(imgPath);
                });
                
                previewContainer.appendChild(img);
            });
        }

        // Add 3D models section if available
        if (models && models.length > 0) {
            const modelsTitle = document.createElement('h5');
            modelsTitle.textContent = 'Mô hình 3D';
            container.appendChild(modelsTitle);

            models.forEach(modelPath => {
                // Create a preview container for the model
                const modelPreviewContainer = document.createElement('div');
                modelPreviewContainer.classList.add('model-preview-container');
                container.appendChild(modelPreviewContainer);
                
                // Create model icon/preview
                const modelIcon = document.createElement('div');
                modelIcon.classList.add('model-icon');
                modelIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="64" height="64"><path fill="currentColor" d="M12 1l8.217 4.895v9.478L12 19.992l-8.217-4.619V5.895L12 1zm0 2.13L5.393 6.787v7.604L12 17.869l6.607-3.478V6.787L12 3.13z"/></svg>';
                
                // Add model file name
                const modelName = document.createElement('span');
                modelName.textContent = modelPath.split('/').pop();
                
                // Add click event for 3D viewer
                modelPreviewContainer.addEventListener('click', () => {
                    show3DModelPopup(modelPath);
                });
                
                modelPreviewContainer.appendChild(modelIcon);
                modelPreviewContainer.appendChild(modelName);
            });
        }

        // If no images or models
        if ((!images || images.length === 0) && (!models || models.length === 0)) {
            const noContentText = document.createElement('p');
            noContentText.textContent = 'Không có dữ liệu.';
            container.appendChild(noContentText);
        }

        return container;
    }

    // Function to highlight the selected item in the sidebar
    function highlightSelectedItem(item) {
        // Remove previous highlight
        const previouslySelected = categoriesContainer.querySelector('.selected-item');
        if (previouslySelected) {
            previouslySelected.classList.remove('selected-item');
        }

        // Find the exact item using both category and full identifier
        const itemIdentifier = `${item.id ? item.id + ' - ' : ''}${item.name}`;
        const allItemNodes = categoriesContainer.querySelectorAll('.item-node');
        
        for (const node of allItemNodes) {
            if (node.textContent === itemIdentifier && node.dataset.category === item.category) {
                node.classList.add('selected-item');
                // Ensure the parent category is expanded
                const parentCategory = node.closest('.category-node');
                if (parentCategory) {
                    parentCategory.classList.add('expanded');
                }
                break; // Stop after finding the correct item
            }
        }
    }

    // Function to handle search input (Updated for Tree View)
    function handleSearch() {
        const searchTerm = searchInput.value.toLowerCase().trim();
        const allCategoryNodes = categoriesContainer.querySelectorAll('.category-node');
        const allItemNodes = categoriesContainer.querySelectorAll('.item-node');

        if (searchTerm === '') {
            // Reset view: hide all items, collapse categories, show all categories
            allItemNodes.forEach(node => node.style.display = 'list-item'); // Show all items initially
            allCategoryNodes.forEach(node => {
                node.style.display = 'list-item'; // Ensure category node itself is visible
                node.classList.remove('expanded'); // Collapse category
            });
            return;
        }

        let hasResults = false;
        allCategoryNodes.forEach(categoryNode => {
            const itemList = categoryNode.querySelector('.item-list');
            const items = itemList.querySelectorAll('.item-node');
            let categoryHasMatch = false;

            items.forEach(itemNode => {
                const itemName = itemNode.textContent.toLowerCase();
                const itemId = itemNode.dataset.itemId.toLowerCase();
                const isMatch = itemName.includes(searchTerm) || itemId.includes(searchTerm);

                itemNode.style.display = isMatch ? 'list-item' : 'none';
                if (isMatch) {
                    categoryHasMatch = true;
                    hasResults = true;
                }
            });

            // Show/hide category based on whether it contains matching items
            categoryNode.style.display = categoryHasMatch ? 'list-item' : 'none';
            // Expand category if it has matches
            if (categoryHasMatch) {
                categoryNode.classList.add('expanded');
            } else {
                categoryNode.classList.remove('expanded');
            }
        });
        // Optionally: Add a message if no results found
        // if (!hasResults) { ... }
    }

    // Add event listener for search input
    searchInput.addEventListener('input', handleSearch);

    // Initial data fetch
    fetchData();
}); 