// Placeholder for JavaScript logic
// This script will handle:
// 1. Fetching data (initially from a JSON file generated by a script)
// 2. Populating categories and items in the sidebar
// 3. Handling search functionality
// 4. Displaying comparison images when an item is selected
// 5. Toggling category visibility

// Import Three.js and FBX loader
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';

document.addEventListener('DOMContentLoaded', () => {
    const categoriesContainer = document.getElementById('categories');
    const comparisonArea = document.getElementById('comparison-area');
    const searchInput = document.getElementById('search-input');
    const noItemSelectedMessage = document.getElementById('no-item-selected');
    const themeToggle = document.getElementById('theme-toggle');
    const lightIcon = document.getElementById('light-icon');
    const darkIcon = document.getElementById('dark-icon');
    const themeText = document.getElementById('theme-text');
    let allItems = []; // To store all items for searching
    let currentData = null; // Store the fetched data
    let modelViewer = null; // 3D model viewer instance

    // Create popup elements
    const popupOverlay = document.createElement('div');
    popupOverlay.className = 'popup-overlay';
    popupOverlay.innerHTML = `
        <div class="popup-content">
            <button class="popup-close">×</button>
            <div class="popup-container">
                <img class="popup-image" src="" alt="Enlarged image" style="display: none;">
                <div class="model-container" style="display: none;">
                    <canvas class="model-canvas"></canvas>
                </div>
            </div>
        </div>
    `;
    document.body.appendChild(popupOverlay);

    const popupImage = popupOverlay.querySelector('.popup-image');
    const modelContainer = popupOverlay.querySelector('.model-container');
    const modelCanvas = popupOverlay.querySelector('.model-canvas');
    const closeButton = popupOverlay.querySelector('.popup-close');

    // Function to show image popup
    function showImagePopup(imageSrc) {
        popupImage.src = imageSrc;
        popupImage.style.display = 'block';
        modelContainer.style.display = 'none';
        popupOverlay.classList.add('active');
        document.body.style.overflow = 'hidden'; // Prevent scrolling when popup is open
    }

    // Function to show 3D model popup
    function show3DModelPopup(modelSrc) {
        popupImage.style.display = 'none';
        modelContainer.style.display = 'block';
        popupOverlay.classList.add('active');
        document.body.style.overflow = 'hidden';
        
        // Initialize 3D viewer if needed
        if (!modelViewer) {
            initModel3DViewer();
        }
        
        // Load the 3D model
        loadModel(modelSrc);
    }

    // Function to initialize 3D viewer
    function initModel3DViewer() {
        modelViewer = {
            scene: null,
            camera: null,
            renderer: null,
            controls: null,
            model: null,
            clock: null,
            mixer: null,
            dispose: function() {
                if (this.model) {
                    this.scene.remove(this.model);
                    // Dispose geometries and materials
                    if (this.model.traverse) {
                        this.model.traverse((child) => {
                            if (child.isMesh) {
                                child.geometry.dispose();
                                if (child.material.isMaterial) {
                                    disposeTextures(child.material);
                                    child.material.dispose();
                                } else if (Array.isArray(child.material)) {
                                    child.material.forEach(material => {
                                        disposeTextures(material);
                                        material.dispose();
                                    });
                                }
                            }
                        });
                    }
                    this.model = null;
                }
                if (this.mixer) {
                    this.mixer = null;
                }
            }
        };

        // Set up the scene
        modelViewer.scene = new THREE.Scene();
        modelViewer.scene.background = new THREE.Color(0x222222);

        // Set up the camera
        modelViewer.camera = new THREE.PerspectiveCamera(45, modelContainer.clientWidth / modelContainer.clientHeight, 0.1, 1000);
        modelViewer.camera.position.set(5, 5, 5);
        
        // Set up the renderer
        modelViewer.renderer = new THREE.WebGLRenderer({ 
            canvas: modelCanvas,
            antialias: true
        });
        modelViewer.renderer.setSize(modelContainer.clientWidth, modelContainer.clientHeight);
        modelViewer.renderer.setPixelRatio(window.devicePixelRatio);
        modelViewer.renderer.shadowMap.enabled = true;
        
        // Set up the controls
        modelViewer.controls = new OrbitControls(modelViewer.camera, modelViewer.renderer.domElement);
        modelViewer.controls.enableDamping = true;
        modelViewer.controls.dampingFactor = 0.05;
        
        // Set up lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        modelViewer.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1);
        directionalLight.castShadow = true;
        modelViewer.scene.add(directionalLight);
        
        // Add a clock for animations
        modelViewer.clock = new THREE.Clock();
        
        // Animation
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            modelViewer.controls.update();
            
            // Update any animations
            if (modelViewer.mixer) {
                modelViewer.mixer.update(modelViewer.clock.getDelta());
            }
            
            // Render the scene
            modelViewer.renderer.render(modelViewer.scene, modelViewer.camera);
        }
        
        // Start the animation loop
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (modelViewer.camera && modelViewer.renderer) {
                modelViewer.camera.aspect = modelContainer.clientWidth / modelContainer.clientHeight;
                modelViewer.camera.updateProjectionMatrix();
                modelViewer.renderer.setSize(modelContainer.clientWidth, modelContainer.clientHeight);
            }
        });
    }

    // Helper function to dispose textures
    function disposeTextures(material) {
        if (material.map) material.map.dispose();
        if (material.lightMap) material.lightMap.dispose();
        if (material.bumpMap) material.bumpMap.dispose();
        if (material.normalMap) material.normalMap.dispose();
        if (material.specularMap) material.specularMap.dispose();
        if (material.envMap) material.envMap.dispose();
        if (material.alphaMap) material.alphaMap.dispose();
        if (material.aoMap) material.aoMap.dispose();
        if (material.displacementMap) material.displacementMap.dispose();
        if (material.emissiveMap) material.emissiveMap.dispose();
        if (material.metalnessMap) material.metalnessMap.dispose();
        if (material.roughnessMap) material.roughnessMap.dispose();
    }

    // Function to load a 3D model
    function loadModel(modelSrc) {
        // Show loading message
        modelContainer.innerHTML = '<div class="loading-spinner">Đang tải mô hình 3D...</div>';
        
        // Clear previous model
        if (modelViewer.model) {
            modelViewer.dispose();
        }
        
        // Create a new canvas
        modelContainer.innerHTML = '';
        const newCanvas = document.createElement('canvas');
        newCanvas.className = 'model-canvas';
        modelContainer.appendChild(newCanvas);
        
        // Update renderer with new canvas
        modelViewer.renderer = new THREE.WebGLRenderer({ 
            canvas: newCanvas,
            antialias: true
        });
        modelViewer.renderer.setSize(modelContainer.clientWidth, modelContainer.clientHeight);
        modelViewer.renderer.setPixelRatio(window.devicePixelRatio);
        modelViewer.renderer.shadowMap.enabled = true;
        
        // Update controls with new domElement
        modelViewer.controls = new OrbitControls(modelViewer.camera, modelViewer.renderer.domElement);
        modelViewer.controls.enableDamping = true;
        modelViewer.controls.dampingFactor = 0.05;
        
        // Load the model
        const loader = new FBXLoader();
        loader.load(
            modelSrc,
            (fbx) => {
                // Successfully loaded the model
                modelViewer.model = fbx;
                
                // Center the model
                const box = new THREE.Box3().setFromObject(fbx);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                // Reset position
                fbx.position.set(-center.x, -center.y, -center.z);
                
                // Set appropriate camera distance
                const maxDim = Math.max(size.x, size.y, size.z);
                const distance = maxDim * 1.5;
                modelViewer.camera.position.set(distance, distance, distance);
                modelViewer.camera.lookAt(new THREE.Vector3(0, 0, 0));
                
                // Add to scene
                modelViewer.scene.add(fbx);
                
                // Handle animations if present
                if (fbx.animations && fbx.animations.length > 0) {
                    modelViewer.mixer = new THREE.AnimationMixer(fbx);
                    const action = modelViewer.mixer.clipAction(fbx.animations[0]);
                    action.play();
                }
                
                // Reset controls
                modelViewer.controls.reset();
            },
            (xhr) => {
                // Progress callback
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            (error) => {
                // Error callback
                console.error('Error loading model:', error);
                modelContainer.innerHTML = '<div class="error-message">Không thể tải mô hình 3D</div>';
            }
        );
    }

    // Function to hide popup
    function hideImagePopup() {
        popupOverlay.classList.remove('active');
        document.body.style.overflow = ''; // Restore scrolling
    }

    // Add event listeners for popup
    closeButton.addEventListener('click', hideImagePopup);
    popupOverlay.addEventListener('click', (e) => {
        if (e.target === popupOverlay) {
            hideImagePopup();
        }
    });

    // Add keyboard support for closing popup
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && popupOverlay.classList.contains('active')) {
            hideImagePopup();
        }
    });

    // Theme toggle functionality
    function initTheme() {
        // Check for saved theme preference or use system preference
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            enableDarkMode();
        } else if (savedTheme === 'light') {
            enableLightMode();
        } else {
            // Use system preference if no saved preference
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                enableDarkMode();
            }
        }
    }

    function enableDarkMode() {
        document.body.classList.add('dark-theme');
        lightIcon.style.display = 'none';
        darkIcon.style.display = 'block';
        themeText.textContent = 'Chế độ sáng';
        localStorage.setItem('theme', 'dark');
    }

    function enableLightMode() {
        document.body.classList.remove('dark-theme');
        lightIcon.style.display = 'block';
        darkIcon.style.display = 'none';
        themeText.textContent = 'Chế độ tối';
        localStorage.setItem('theme', 'light');
    }

    themeToggle.addEventListener('click', () => {
        if (document.body.classList.contains('dark-theme')) {
            enableLightMode();
        } else {
            enableDarkMode();
        }
    });

    // Initialize theme
    initTheme();

    // Function to fetch data and initialize the page
    async function fetchData() {
        try {
            // Use the GitHub raw URL directly as it's confirmed to be working
            const directUrl = 'https://raw.githubusercontent.com/kienbb/MU-Art-Compare/main/docs/data.json';
            
            console.log('Fetching data directly from GitHub:', directUrl);
            
            const response = await fetch(directUrl);
            if (!response.ok) {
                console.error(`Failed to fetch from GitHub raw. Status: ${response.status}`);
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            currentData = await response.json();
            populateTreeSidebar(currentData.categories);
            collectAllItems(currentData.categories);
        } catch (error) {
            console.error("Could not fetch data:", error);
            categoriesContainer.innerHTML = `<p style="color: red;">Lỗi tải dữ liệu. Vui lòng kiểm tra kết nối mạng và thử lại.</p>`;
        }
    }

    // Function to populate the sidebar as a tree
    function populateTreeSidebar(categoriesData) {
        categoriesContainer.innerHTML = ''; // Clear previous content
        const treeRoot = document.createElement('ul');
        treeRoot.classList.add('category-tree');

        // Clear and setup content area structure
        const content = document.getElementById('content');
        content.innerHTML = `
            <div class="content-header">
                <h2>So sánh chi tiết</h2>
            </div>
            <div class="content-body">
                <div id="comparison-area">
                    <p id="no-item-selected">Chọn một mục từ danh sách bên trái để xem so sánh.</p>
                </div>
            </div>
        `;

        if (!categoriesData || Object.keys(categoriesData).length === 0) {
            const noDataMsg = document.createElement('p');
            noDataMsg.textContent = 'Không có dữ liệu danh mục. Vui lòng thêm dữ liệu vào thư mục assets và chạy "npm run scan".';
            noDataMsg.style.color = 'red';
            categoriesContainer.appendChild(noDataMsg);
            return;
        }

        for (const categoryName in categoriesData) {
            const items = categoriesData[categoryName];
            if (items && items.length > 0) {
                // Create category node
                const categoryNode = document.createElement('li');
                categoryNode.classList.add('category-node');

                const categoryTitle = document.createElement('span');
                categoryTitle.textContent = categoryName;
                categoryTitle.classList.add('category-title');
                categoryNode.appendChild(categoryTitle);

                // Create list for items within the category
                const itemList = document.createElement('ul');
                itemList.classList.add('item-list'); // Initially hidden by CSS

                items.forEach(item => {
                    const itemNode = document.createElement('li');
                    itemNode.classList.add('item-node');
                    itemNode.textContent = `${item.id ? item.id + ' - ' : ''}${item.name}`; // Display ID and name
                    itemNode.dataset.category = categoryName;
                    itemNode.dataset.itemId = item.id || item.name.replace(/ /g, '_'); // Use ID or name as identifier
                    itemNode.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent category toggle when item is clicked
                        displayComparison(item);
                    });
                    itemList.appendChild(itemNode);
                });

                categoryNode.appendChild(itemList);

                // Add click listener to category title to toggle item list
                categoryTitle.addEventListener('click', () => {
                    categoryNode.classList.toggle('expanded');
                });

                treeRoot.appendChild(categoryNode);
            } else {
                // Create empty category node with message
                const categoryNode = document.createElement('li');
                categoryNode.classList.add('category-node');

                const categoryTitle = document.createElement('span');
                categoryTitle.textContent = categoryName;
                categoryTitle.classList.add('category-title');
                categoryNode.appendChild(categoryTitle);

                const emptyMsg = document.createElement('p');
                emptyMsg.textContent = 'Không có mục nào trong danh mục này';
                emptyMsg.style.fontSize = '0.9em';
                emptyMsg.style.fontStyle = 'italic';
                emptyMsg.style.marginLeft = '20px';

                categoryNode.appendChild(emptyMsg);
                treeRoot.appendChild(categoryNode);
            }
        }
        categoriesContainer.appendChild(treeRoot);
    }

    // Function to collect all items for search functionality
    function collectAllItems(categoriesData) {
        allItems = [];
        for (const categoryName in categoriesData) {
            categoriesData[categoryName].forEach(item => {
                allItems.push(item);
            });
        }
    }

    // Function to display comparison images
    function displayComparison(item) {
        const comparisonArea = document.getElementById('comparison-area');
        comparisonArea.innerHTML = ''; // Clear previous comparison

        // Update the title to include the selected item name
        const contentTitle = document.querySelector('.content-header h2');
        contentTitle.textContent = `So sánh chi tiết - ${item.id ? item.id + ' - ' : ''}${item.name}`;

        // Create containers for each version
        const awakenContainer = createImageContainer('MU Awaken', item.images.awaken, item.models?.awaken);
        const originContainer = createImageContainer('MU Origin', item.images.origin, item.models?.origin);

        comparisonArea.appendChild(awakenContainer);
        comparisonArea.appendChild(originContainer);

        // Highlight selected item in sidebar
        highlightSelectedItem(item);
    }

    // Helper function to create image container for a version
    function createImageContainer(versionName, images, models) {
        const container = document.createElement('div');
        container.classList.add('image-container');

        const title = document.createElement('h4');
        title.textContent = versionName;
        container.appendChild(title);

        // Add images section
        if (images && images.length > 0) {
            const imagesTitle = document.createElement('h5');
            imagesTitle.textContent = 'Hình ảnh';
            container.appendChild(imagesTitle);

            images.forEach(imgPath => {
                // Create a fixed-size container for the image
                const previewContainer = document.createElement('div');
                previewContainer.classList.add('image-preview-container');
                container.appendChild(previewContainer);
                
                // Create and add the image to the container
                const img = document.createElement('img');
                img.src = imgPath;
                img.alt = `${versionName} image`;
                
                // Add click event for popup
                previewContainer.addEventListener('click', () => {
                    showImagePopup(imgPath);
                });
                
                previewContainer.appendChild(img);
            });
        }

        // Add 3D models section if available
        if (models && models.length > 0) {
            const modelsTitle = document.createElement('h5');
            modelsTitle.textContent = 'Mô hình 3D';
            container.appendChild(modelsTitle);

            models.forEach(modelPath => {
                // Create a preview container for the model
                const modelPreviewContainer = document.createElement('div');
                modelPreviewContainer.classList.add('model-preview-container');
                container.appendChild(modelPreviewContainer);
                
                // Create model icon/preview
                const modelIcon = document.createElement('div');
                modelIcon.classList.add('model-icon');
                modelIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="64" height="64"><path fill="currentColor" d="M12 1l8.217 4.895v9.478L12 19.992l-8.217-4.619V5.895L12 1zm0 2.13L5.393 6.787v7.604L12 17.869l6.607-3.478V6.787L12 3.13z"/></svg>';
                
                // Add model file name
                const modelName = document.createElement('span');
                modelName.textContent = modelPath.split('/').pop();
                
                // Add click event for 3D viewer
                modelPreviewContainer.addEventListener('click', () => {
                    show3DModelPopup(modelPath);
                });
                
                modelPreviewContainer.appendChild(modelIcon);
                modelPreviewContainer.appendChild(modelName);
            });
        }

        // If no images or models
        if ((!images || images.length === 0) && (!models || models.length === 0)) {
            const noContentText = document.createElement('p');
            noContentText.textContent = 'Không có dữ liệu.';
            container.appendChild(noContentText);
        }

        return container;
    }

    // Function to highlight the selected item in the sidebar
    function highlightSelectedItem(item) {
        // Remove previous highlight
        const previouslySelected = categoriesContainer.querySelector('.selected-item');
        if (previouslySelected) {
            previouslySelected.classList.remove('selected-item');
        }

        // Find the exact item using both category and full identifier
        const itemIdentifier = `${item.id ? item.id + ' - ' : ''}${item.name}`;
        const allItemNodes = categoriesContainer.querySelectorAll('.item-node');
        
        for (const node of allItemNodes) {
            if (node.textContent === itemIdentifier && node.dataset.category === item.category) {
                node.classList.add('selected-item');
                // Ensure the parent category is expanded
                const parentCategory = node.closest('.category-node');
                if (parentCategory) {
                    parentCategory.classList.add('expanded');
                }
                break; // Stop after finding the correct item
            }
        }
    }

    // Function to handle search input (Updated for Tree View)
    function handleSearch() {
        const searchTerm = searchInput.value.toLowerCase().trim();
        const allCategoryNodes = categoriesContainer.querySelectorAll('.category-node');
        const allItemNodes = categoriesContainer.querySelectorAll('.item-node');

        if (searchTerm === '') {
            // Reset view: hide all items, collapse categories, show all categories
            allItemNodes.forEach(node => node.style.display = 'list-item'); // Show all items initially
            allCategoryNodes.forEach(node => {
                node.style.display = 'list-item'; // Ensure category node itself is visible
                node.classList.remove('expanded'); // Collapse category
            });
            return;
        }

        let hasResults = false;
        allCategoryNodes.forEach(categoryNode => {
            const itemList = categoryNode.querySelector('.item-list');
            const items = itemList.querySelectorAll('.item-node');
            let categoryHasMatch = false;

            items.forEach(itemNode => {
                const itemName = itemNode.textContent.toLowerCase();
                const itemId = itemNode.dataset.itemId.toLowerCase();
                const isMatch = itemName.includes(searchTerm) || itemId.includes(searchTerm);

                itemNode.style.display = isMatch ? 'list-item' : 'none';
                if (isMatch) {
                    categoryHasMatch = true;
                    hasResults = true;
                }
            });

            // Show/hide category based on whether it contains matching items
            categoryNode.style.display = categoryHasMatch ? 'list-item' : 'none';
            // Expand category if it has matches
            if (categoryHasMatch) {
                categoryNode.classList.add('expanded');
            } else {
                categoryNode.classList.remove('expanded');
            }
        });
        // Optionally: Add a message if no results found
        // if (!hasResults) { ... }
    }

    // Add event listener for search input
    searchInput.addEventListener('input', handleSearch);

    // Initial data fetch
    fetchData();
}); 